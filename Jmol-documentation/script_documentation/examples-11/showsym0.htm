<html>
<head>
<title>Jmol Crystal Symmetry Explorer</title>
<script type="text/javascript" src="Jmol.js"></script>
<script type="text/javascript">

jmolInitialize(".","JmolAppletSigned0.jar")

var Models = "nepheline.cif,troilite.cif,quartz.cif,04369a.cif {1 1 1},AgFUPMOS.cif {1 1 1},diamond.cif,dickite.cif,gold.cif,\
kuds0105a.ccdc.cif {1 1 1},calcite.cif 1 packed,Ti2O3.cif,icsd_200866.cif 1 packed,icsd_250072.cif,icsd_26520.cif,\
maleic.cif 5 {1 1 1},nacl.cif,nank0104a.ccdc.cif {1 1 1},sebi0105c.ccdc.cif {1 1 1}".split(",")

var modelSelectHtml
var defaultScript = ""

/*

  http://chemapps.stolaf.edu/jmol/docs/examples-11/showsym.htm
  Jmol Crystal Symmetry Explorer
  Bob Hanson, 8/21/2009
  for the 238th American Chemical Society National Meeting, Washington, D.C.

  This page graphically displays symmetry operators for a model. 
  You can load any of the examples here or any file of your own.

  This file involves three sections:

	JavaScript functions
	body HTML
	Jmol script functions (embedded in body)

*/

/// initial HTML for the page

selectedModel = ""
functionScript = ""

function getModelSelectHtml() {
	Models = Models.sort()
	var xxxx = document.location.search
	var isDefault = true
	if (xxxx.indexOf("?load") == 0) {
		defaultScript = unescape(xxxx.substring(1))
		isDefault = false
	} else if (xxxx.length > 1) {
		selectedModel = xxxx
		if (xxxx.indexOf(" ") < 0)xxxx += " packed"
		isDefault = false
		defaultScript = 'set echo top left;echo loading ' + selectedModel + '...;refresh;load ' + xxxx + ';echo "";'
	}
	var s = "<select id='modelselect' onchange=getModel() onkeypress=\"setTimeout('getModel()',50)\"><option value=''>select a model</option>"
	if (!isDefault) {
		var S = selectedModel.split("/")
		s += "<option selected value='"+selectedModel+"'>" + S[S.length - 1] + "</option>"
	}
	for (var i = 0; i < Models.length; i++) {
		var m = Models[i]
		var isSelected = (m.indexOf("*")>=0 && isDefault)
		m = m.replace(/\*/,"")
		if (m.indexOf(" ") < 0)m += " packed"
		if (isSelected)selectedModel = m
		s += "<option value='data/" + m + "' " + (isSelected ? " selected": "") + ">" + m.split(".")[0] + "</option>"
	}
	s += "</select>"
	modelSelectHtml = s
	if (selectedModel && selectedModel.indexOf("/") < 0) selectedModel = "data/" + selectedModel
	if (selectedModel && !defaultScript)defaultScript = "load " + selectedModel

}getModelSelectHtml()

//// user actions from selections

function getModel(justCheck) {
	var d = document.getElementById("modelselect")
	if (d.selectedIndex == 0)return
	var model = d[d.selectedIndex].value
	if (!model || justCheck && model == selectedModel)return
	selectedModel = model
	jmolScript("load " + model)
}

function getTxtOp() {
	getSelect(document.getElementById("txtop").value)
}

function getSelect(symop) {
	var showatoms = document.getElementById("chkatoms").checked
	jmolScript("display " + (showatoms ? "all" : "none"))
	var d = document.getElementById("symselect")
	var iop = parseInt(d[d.selectedIndex].value)
	if (!iop && !symop) symop = document.getElementById("txtop").value
	if (!symop) {
		if (!iop) {
			jmolScript("select *;color opaque;draw sym_* delete")
			return
		}
		symop = d[d.selectedIndex].text.split("(")[1].split(")")[0]
		document.getElementById("txtop").value = symop
	}
	var d = document.getElementById("atomselect")
	var atomi = d.selectedIndex
	var pt00 = d[d.selectedIndex].value
	var atomindex = -1
	if (pt00.indexOf("{") < 0) {
		atomindex = pt00
		pt00 = "{atomindex=" + pt00 + "}.xyz"
	}
	var d = document.getElementById("selopacity")
	var opacity = parseFloat(d[d.selectedIndex].value)
	if (opacity < 0) opacity = 1
	var normalizing = false//document.getElementById("chknormalized").checked
	var script = "select *;color atoms translucent " + (1-opacity)
	script += ";pt00 = " + pt00 + ";showSym(\"" + symop + "\",pt00,false,'');"
	if (atomi == 0)script += ";select symop=1 or symop=" + iop + ";color opaque;"
	script = "set echo top right;echo \"\";" + script
	jmolScript(script)
}

function doarrow(x) {
	var d = document.getElementById("symselect")
	x += d.selectedIndex
	if (x < 0 || x >= d.length) return
	d.selectedIndex = x
	getSelect()
}

/// Jmol callbacks

function errorCallback(a, b, msg) {
 alert(msg)
}

function loadstructCallback() {
	setTimeout('getSymInfo()',100) // need the timeout to get another thread or this will lock 
}

function pickCallback(a,b,i) {
	var d = document.getElementById("atomselect")
	d.selectedIndex = i + 3
	getSelect()
}

function getSymInfo() {

	if (!functionScript) {
		functionScript = document.body.innerHTML.split("JMOLSCRIPT")[1]
		jmolScriptWait(functionScript)
	}

	// update all of the model-specific page items

	var s = ""
	var info = jmolEvaluate('script("show spacegroup")')
	if (info.indexOf("x,") < 0) {
		s = "no space group"
	} else {
		var S = info.split("\n")
		var hm = "?"
		var itcnumber = "?"
		var hallsym = "?"
		var latticetype = "?"
		var nop = 0 
		var slist = ""
		for (var i = 0; i < S.length; i++) {
			var line = S[i].split(":")
			if (line[0].indexOf("Hermann-Mauguin symbol") == 0)
				s += "<br>" + S[i]
			else if (line[0].indexOf("international table number") == 0)
				s += "<br>" + S[i]
			else if (line[0].indexOf("Hall symbol") == 0)
				s += "<br>" + S[i]
			else if (line[0].indexOf("lattice type") == 0)
				s += "<br>" + S[i]
			else if (line[0].indexOf(" employed") >= 0)
				nop = parseInt(line[0])
			else if (nop > 0 && line[0].indexOf(",") >= 0)
				slist += "|" + fixSym(line[0])
		}
		s += "<br><br><a href=javascript:doarrow(-1)><img align=bottom src=arrowleft.png border=0 /></a> "
		s += nop + " operators"
		s += " <a href=javascript:doarrow(1)><img align=bottom src=arrowright.png border=0 /></a>"
		var info = jmolEvaluate('getSymmetryDetails("' + slist + '")')
		var S = info.split("\n")
		var n = 0;
		var i = -1;while (S[++i].indexOf(",") < 0){}
		s += "<br><select id='symselect' onchange=getSelect() onkeypress=\"setTimeout('getSelect()',50)\"><option value=0>select a symmetry operation</option>"
		for (;i < S.length;i++)
			if (S[i].indexOf("x") >= 0) 
				s += "<option value='" + (++n) + "'>" + n + ":  " + fixSym(S[i]) + "</option>" 
		s += "</select>"
		s += "</br><input type=text id=txtop width=30 value='1-x,1-y,1-z' /><a href=javascript:getTxtOp()>show</a>"
		s += "</br><input type=checkbox id=chkatoms onchange=getSelect() />show atoms"
		s += " opacity:<select id=selopacity onchange=getSelect() onkeypress=\"setTimeout('getSelect()',50)\">"
		  + "<option value=0.2 selected>20%</option>"
		  + "<option value=0.4>40%</option>"
		  + "<option value=0.6>60%</option>"
		  + "<option value=1.0>100%</option>"
		  + "</select>"
		
		var info = jmolEvaluate('{*}.label("#%i %a {%[fxyz]/1}")').split("\n")
		var nPoints = info.length
		var nBase = jmolEvaluate('{symop=1}.length')
		s += "<br><select id='atomselect' onchange=getSelect() onkeypress=\"setTimeout('getSelect()',50)\"><option value=0>base atoms</option>"
		s += "<option value='{0 0 0}'>{0 0 0}</option>"
		s += "<option value='{1/2 1/2 1/2}'>{1/2 1/2 1/2}</option>"
		for (var i = 0; i < nPoints; i++)
			s+= "<option value=" + i + (i == 0 ? " selected" : "") + ">" + info[i] + "</option>" 
		s += "</select>"
	}
	document.getElementById("syminfo").innerHTML = s
}

function fixSym(xyz) {
	if (xyz.indexOf(",") < 0)return xyz
	var s = "," + (xyz.indexOf(":") >= 0 ? xyz.split(":")[1] : xyz.split("\t")[1]) + ","
/*
	s = s.replace(/ /g,"")
		.replace(/,-1\/2/g,",+1/2")
		.replace(/,-x-1\/2,/,",1/2-x,")
		.replace(/,-y-1\/2,/,",1/2-y,")
		.replace(/,-z-1\/2,/,",1/2-z,")
		.replace(/,-x/g,",1-x")
		.replace(/,-y/g,",1-y")
		.replace(/,-z/g,",1-z")
		.replace(/,x-y/g,",1+x-y")
		.replace(/,1-x\+1/,",-x+1")
		.replace(/,1-y\+1/,",-y+1")
		.replace(/,1-z\+1/,",-z+1")
		.replace(/,1\+x-y/,",x-y")
		.replace(/,1\+y-x/,",y-x")
		.replace(/5\/6/,"-1/6")
		.replace(/--/,",")
*/
	s = s.substring(1,s.length-1)
	if (xyz.indexOf(":") < 0) return s
	xyz = xyz.split(":")[2].split("|")[0]
	return xyz + " (" + s + ")"
}

</script>
</head>
<body>

<table><tr>
<td align=center valign=top style="width:170px">
<h3>Jmol Crystal Symmetry Explorer</h3>



<script type="text/javascript">
jmolBr()
_jmol.buttonCssText="style='width:160'"
jmolBr()
jmolButton("load \"\" {1 1 1}")
jmolBr()
jmolButton("load \"\" 1 packed")
jmolBr()
jmolButton("load \"\" 1 {555 555 1}")
jmolBr()
jmolButton("load \"\" 1 {444 666 1}")
jmolBr()
jmolButton("load \"\" 1 {455 655 1}")
jmolBr()
jmolButton("load \"\" 1 {545 565 1}")
jmolBr()
jmolButton("load \"\" 1 {554 556 1}")
jmolBr()
jmolButton("load \"\" 1 {445 665 1}")
jmolBr()
jmolButton("load \"\" 1 {454 656 1}")
jmolBr()
jmolButton("load \"\" 1 {544 566 1}")
jmolBr()
jmolButton("backgroundcolor = (backgroundcolor = '[x000000]' ? 'white' : 'black')","background")
jmolBr()
</script>
<br>
Produced especially for the 238th ACS Meeting in Washington, D.C., <a href=http://oasys2.confex.com/acs/238nm/techprogram/P1283308.HTM>Teaching Molecular Structure Using Jmol</a>
presented by <a target=_blank href=http://stolaf.edu/people/hansonr>Bob Hanson</a>, Aug. 19, 2009.
</td>
<td align=center  valign=top>

<script type="text/javascript">
jmolApplet(["600","600"],';background white;set antialiasdisplay;set errorCallback "errorCallback";set loadstructcallback "loadstructCallback";set pickCallback "pickCallback";set zoomlarge false;' + defaultScript)
_jmol.buttonCssText="style='width:100'"
jmolBr()
jmolButton("console")
jmolCommandInput()

</script>
</td><td  valign=top>
<script type="text/javascript">
document.write(modelSelectHtml)
</script>
<div id='syminfo'></div>

<br>
<br>
<br>
<script type="text/javascript">
_jmol.buttonCssText="style='width:160'"
jmolButton("load file \"?\" 1 packed","Load URL or FILE")
jmolBr()
jmolButton("script ?.spt","Load SCRIPT")
jmolBr()
jmolButton("write FILE ?","Save FILE")
jmolBr()
jmolButton("write STATE ?.spt","Save STATE")
jmolBr()
jmolButton("write IMAGE ?.jpg","Save JPG")
jmolBr()
jmolButton("write IMAGE ?.png","Save PNG")
jmolBr()
</script>

</td></tr>
</table>


<!-- JMOLSCRIPT

// all of the rest of this is Jmol script embedded in the body of the HTML page

function showsym(sym, pt00, typeonly, id) {

	/* 
		Jmol script to display symmetry for a symmetry operator

		parameters

	*/

	// Jmol does not distinguish case, but JavaScript replace does, so
	// this little trick serves to allow the JavaScript calling method
	// to substitute values into the script prior to sending it to Jmol.

	if (pt00.type != "point")pt00 = {atomno=1}.xyz
	if (!typeonly)typeonly = false
	if (!id)id = "sym_"

	var a = {atomno=1}

	var pt0 = pt00

	// initial red/green/blue frame

	var pt01 = pt00 + {1 0 0}
	var pt02 = pt00 + {0 1 0}
	var pt03 = pt00 + {0 0 1}


	// frame after operation (red/green/purple)

	var p0 = a.symop(sym,pt00)
	var p1 = a.symop(sym,pt01)
	var p2 = a.symop(sym,pt02)
	var p3 = a.symop(sym,pt03)

	// The first trick is to check cross products to see if we still have a right-hand axis.
 
	var haveinversion = (cross(p1 - p0, p2 - p0) * (p3 - p0) < 0)

	if (haveinversion){

		// undo inversion for quaternion analysis (requires proper rotations only)

		var pi1 = p1
		var pi2 = p2
		var pi3 = p3

		p1 = p0 + p0 - p1
		p2 = p0 + p0 - p2
		p3 = p0 + p0 - p3

	}

	// The second trick is to use quaternions. Each of the three faces of the frame (xy, yz, and zx)
	// is checked. The helix() function will return data about the local helical axis, and the
	// symop(sym,{0 0 0}) function will return the overall translation.

	var info1 = helix(pt00,p0,quaternion(p0, p1, p2)/quaternion(pt00, pt01, pt02))
	//print info1
	var pa1 = info1[1]
	var ax1 = info1[2]
	var ang1 = abs((info1[4].x)%0)
	var pitch1 = (info1[4].y)%2

	info1 = helix(pt00,p0,quaternion(p0, p2, p3)/quaternion(pt00, pt02, pt03))
	//print info1
	var ax2 = info1[2]
	var ang2 = abs((info1[4].x)%0)

	info1 = helix(pt00,p0,quaternion(p0, p3, p1)/quaternion(pt00, pt03, pt01))
	//print info1
	var ax3 = info1[2]
	var ang3 = abs((info1[4].x)%0)

	var trans = a.symop(sym,{0 0 0})

	if (haveinversion){
		p1 = pi1
		p2 = pi2
		p3 = pi3
	}

	//////////// determination of type of operation from first principles

	var isinversion = false
	var ismirrorplane = false
	var ptinv = 0	// inverted point for translucent frame
	var ipt = 0         // inversion center
	var pt0 = pt00      // reflection center

	var istranslation = (ang1 == 0 && ang2 == 0 && ang3 == 0)

	// unit axes

	var n1 = ax1/ax1
	var n2 = ax2/ax2
	var n3 = ax3/ax3

	var isrotation = !istranslation && (abs((n1*n2)%2) == 1) 
		&& (abs((n2*n3)%2) == 1) 
		&& (abs((n3*n1)%2) == 1)

	if (isrotation || haveinversion)trans = 0

	// handle inversion

	if (haveinversion && istranslation) {

		// simple inversion operation

		ipt = (pt00 + p0)/2
		ptinv = p0
		isinversion = true

	} else if (haveinversion) {

      /*
       * 
       * We must convert simple rotations to rotation-inversions; 2-screws to
       * planes and glide planes.
       * 
       * The idea here is that there is a relationship between the axis for a
       * simple or screw rotation of an inverted frame and one for a
       * rotation-inversion. The relationship involves two adjacent equilateral
       * triangles:
       * 
       *      o 
       *     / \
       *    /   \    i'
       *   /     \ 
       *  /   i   \
       *A/_________\A' 
       * \         / 
       *  \   j   / 
       *   \     / 
       *    \   / 
       *     \ / 
       *      x
       * 
       * Points i and j are at the centers of the triangles. Points A and A' are
       * the frame centers; an operation at point i, j, x, or o is taking A to
       * A'. Point i is 2/3 of the way from x to o. In addition, point j is half
       * way between i and x.
       * 
       * The question is this: Say you have an rotation/inversion taking A to
       * A'. The relationships are:
       * 
       * 6-fold screw x for inverted frame corresponds to 6-bar at i for actual frame 
       * 3-fold screw i for inverted frame corresponds to 3-bar at x for actual frame
       * 
       * The proof of this follows. Consider point x. Point x can transform A to
       * A' as a clockwise 6-fold screw axis. So, say we get that result for the
       * inverted frame. What we need for the real frame is a 6-bar axis
       * instead. Remember, though, that we inverted the frame at A to get this
       * result. The real frame isn't inverted. The 6-bar must do that inversion
       * AND also get the frame to point A' with the same (clockwise) rotation.
       * The key is to see that there is another axis -- at point i -- that does
       * the trick.
       * 
       * Take a look at the angles and distances that arise when you project A
       * through point i. The result is a frame at i'. Since the distance i-i'
       * is the same as i-A (and thus i-A') and the angle i'-i-A' is 60 degrees,
       * point i is also a 6-bar axis transforming A to A'.
       * 
       * Note that both the 6-fold screw axis at x and the 6-bar axis at i are
       * both clockwise.
       * 
       * Similar analysis shows that the 3-fold screw i corresponds to the 3-bar
       * axis at x.
       * 
       * So in each case we just calculate the vector i-j or x-o and then factor
       * appropriately.
       * 
       * The 4-fold case is simpler -- just a parallelogram.
       */


		var d = (pitch1 == 0 ? {0 0 0} : ax1)
		var f = 0
		if (ang1 == 60) {	 	// 6_1 at x  to  6-bar at i
			f = 2.0/3.0
		} else if (ang1 == 120) {	// 3_1 at i  to  3-bar at x
			f = 2
		} else if (ang1 == 90) { 	// 4_1  to  4-bar at opposite corner
			f = 1
		} else if (ang1 == 180) {	// 2_1  to  mirror plane
			// C2 with inversion is a mirror plane -- but could have a glide component.
			pt0 = pt00 + d
			pa1 = pt00 + d/2
			trans = (pt0.distance(p0) > 0.2 ? p0 - pt0 : 0)
			isrotation = false
			haveinversion = false
			ismirrorplane = true
		}
		if (f) {
			pa1 = pa1 + ((pt00 - pa1) + (p0 - (pa1 + d))) * f
			ipt = pa1 + d/2
			ptinv = ipt + ipt - pt00
		}
	} else if (trans) {

		// get rid of unnecessary translations added to keep most operations within cell 555

		if ((trans.fx)%2 == 1)trans = point(0, trans.y, trans.z)
		if ((trans.fy)%2 == 1)trans = point(trans.x, 0, trans.z)
		if ((trans.fz)%2 == 1)trans = point(trans.x, trans.y, 0)
	}


	// time to get the description

	info1 = ""

	if (isinversion) {
		info1 = "inversion center|" + fcoord(ipt)
	} else if (isrotation) {
		if (haveinversion) {
			info1= "" + (360 / ang1) + "-bar axis"
		} else if (pitch1) {
			info1= "" + (360 / ang1) + "-fold screw axis"
		} else {
			info1= "C" + (360 / ang1) + " axis"
		}
	} else if (trans) {
		var s = " " + fcoord(trans)
		if (istranslation) {
			info1 = "translation:" + s
		} else if (ismirrorplane) {
			var fx = trans.fx%2
			var fy = trans.fy%2
			var fz = trans.fz%2
			s = " " + fcoord(trans)
			if (fx != 0 && fy != 0 && fz != 0)
				info1 = "d-"
			else if (fx != 0 && fy != 0 || fy != 0 && fz != 0 || fz != 0 && fx != 0)
				info1 = "n-"
			else if (fx != 0)
				info1 = "a-"
			else if (fy != 0)
				info1 = "b-"
			else
				info1 = "c-"
			endif 
			info1 += "glide plane |translation:" + s
		}
	} else if (ismirrorplane) {
		info1= "mirror plane"
	}

	if (haveinversion && !isinversion) {
		info1 += "|inversion center at " + fcoord(ipt)
	}

	// all after this is just drawing

	if (typeonly) return info1

	// draw two frames -- one just a bit fatter and shorter than the other
	// so that they can both still be seen if on top of each other

	draw ID @{id + "*"} delete

	draw ID @{id + "frame1X"} diameter 0.15 @pt00 @pt01 color red
	draw ID @{id + "frame1Y"} diameter 0.15 @pt00 @pt02 color green
	draw ID @{id + "frame1Z"} diameter 0.15 @pt00 @pt03 color blue
	draw ID @{id + "frame2X"} diameter 0.20 @p0 @{p0 + (p1-p0)*0.9} color red
	draw ID @{id + "frame2Y"} diameter 0.20 @p0 @{p0 + (p2-p0)*0.9} color green
	draw ID @{id + "frame2Z"} diameter 0.20 @p0 @{p0 + (p3-p0)*0.9} color purple

	// draw the lines associated with a rotation

	if (isrotation) {
		col = "red"
		if (haveinversion) {
			draw ID @{id + "invRotation"} arrow @ptinv @p0
			draw ID @{id + "invLine"} @ipt @p0
		} else if (pitch1 == 0) {

			draw ID @{id + "rotRotation"} arrow @pt00 @pt0

			draw ID @{id + "rotLine1"} @pt00 @pa1
			draw ID @{id + "rotLine2"} @p0 @pa1
			ax1 *= 3
			col = "orange"
			draw ID @{id + "rotVector2"} vector diameter 0.1 @pa1 @{-ax1} color @col
		} else {
			draw ID @{id + "rotLine1"} @pt00 @pa1
			draw ID @{id + "rotLine2"} @p0 @{pa1 + ax1}
		}
		draw ID @{id + "rotVector1"} vector diameter 0.1 @pa1 @ax1 color @col
	}

	// draw the mirror plane

	if (ismirrorplane) {
		if (pt00.distance(pt0) > 0.2)draw ID @{id + "planeVector"} arrow @pt00 @pt0 color indigo
		draw ID @{id + "planeCircle"}  scale 2.0 circle @pa1 @{pa1 + ax1} color translucent @{(trans ? "blue" : "green")} mesh fill
		if (trans) {
			draw ID @{id + "planeFrameX"} diameter 0.15 @pt0 @{pt0 + p1 - p0} color translucent red
			draw ID @{id + "planeFrameY"} diameter 0.15 @pt0 @{pt0 + p2 - p0} color translucent green
			draw ID @{id + "planeFrameZ"} diameter 0.15 @pt0 @{pt0 + p3 - p0} color translucent blue
		}
	}

	// draw a faint frame showing the inversion

	if (haveinversion) {
		draw ID @{id + "invPoint"} diameter 0.4 @ipt
		draw ID @{id + "invArrow"} arrow @pt00 @ptinv color indigo
		if (!isinversion) {
			draw ID @{id + "invFrameX"} diameter 0.15 @ptinv @{ptinv + pt00 - pt01} color translucent red
			draw ID @{id + "invFrameY"} diameter 0.15 @ptinv @{ptinv + pt00 - pt02} color translucent green
			draw ID @{id + "invFrameZ"} diameter 0.15 @ptinv @{ptinv + pt00 - pt03} color translucent blue
		}
	}

	// and display translation if still not {0 0 0}

	if (trans) {
		draw ID @{id + "transVector"} vector @pt0 @trans
	}

	// color the targeted atoms opaque and add another frame if necessary

	color @{within(0.2,pt00) or within(0.2,p0)} opaque
	if (within(0.2,p0).length == 0) {
		set2 = within(0.2,p0.uxyz.xyz)
		if (set2) {
			color @set2 opaque
			draw ID @{id + "cellOffsetVector"} arrow @p0 @set2 color grey
			p1 = set2.xyz + p1 - p0
			p2 = set2.xyz + p2 - p0
			p3 = set2.xyz + p3 - p0
			p0 = set2.xyz
			draw ID @{id + "offsetFrameX"} diameter 0.20 @p0 @{p0 + (p1-p0)*0.9} color red
			draw ID @{id + "offsetFrameY"} diameter 0.20 @p0 @{p0 + (p2-p0)*0.9} color green
			draw ID @{id + "offsetFrameZ"} diameter 0.20 @p0 @{p0 + (p3-p0)*0.9} color purple
		}
	}
	
	// finally, echo the information

	info1 = info1 + "|" + sym
	echo @info1

	return info1
}

function fcoord(p) {
	return fc(p.fx) + " " + fc(p.fy) + " " + fc(p.fz)
}

function fc(x) {
	var m = (x < 0 ? "-" : "")
	if (m) x = -x
	var x24 = (x * 24)%0
	if (x24 == 0)return "0"
	if (x24 == 24)return m + "1"
	if (x24 == 12)return m + "1/2"
	if (x24%8 == 0)return m + (x24/8) + "/3"
	if (x24%6 == 0)return m + (x24/6) + "/4"
	if (x24%4 == 0)return m + (x24/4) + "/6"
	if (x24%3 == 0)return m + (x24/3) + "/8"
	return m + x
}

function getSymmetryDetails(slist) {
	var sout = ""
	if (slist) {
		slist = slist.split("|")
	} else {
		slist = script("show symmetry").split("\n")
	}
	var n = slist.length
	var i = 0
	while(slist[++i].find("x,") == 0 && i <= slist.length) {
		print slist[i]
	}
	var pt = 1
	for (j=i; j <= n; j++) {
		if (slist[j].find(",")) {
			sout += "" + (pt++) + ": " + slist[j] + ": " + showsym(slist[j],0,true) + "\n"
		}
	}
	print sout
	return sout
}


JMOLSCRIPT -->


</body>
</html>