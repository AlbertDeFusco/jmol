function renderMode(style) {
	hbonds off
	meshribbon off
	wireframe off
	strand off
	spacefill off
	set navigationMode false
	switch(style) {
	case "meshribbon":
		meshribbon on
		break
	case "strand":
		strand 0.2
		break
	case "spacefill":
		spacefill 1.5
		break
	}
}

function checkPoint(doCheck) {
	if (doVisualize != "rollerCoaster") {
		switch(doCheck) {
		case 0:
			break
		case 1:
			pause
			break
		case 2:
			markDomain()
		}
	}
}

function colorMotifs(colorMode) {
	if (colorMode = "on") {
		color {chain = 0 and nucleic and property_motif > 0} white
		markMotifs = "on"
	} else if (colorMode = "off") {
		select {chain = 0 and nucleic}
		color {selected} group
		markMotifs = "off"
	}
}

# Define Steitz/Moore domain variables

	domains = {"I":{chain = 0 and 10-531},"II":{chain = 0 and 532-1366},"III":{chain = 0 and 1367-1723},"IV":{chain = 0 and 1724-2063},"V":{chain = 0 and 2064-2663},"VI":{chain = 0 and 2667-2914}}

function puzzlePieces(packing) {
	select {*}
	wireframe off
	if (packing = "unpack") {
		domainCoords = {"I":@{domains["I"]}.xyz,"II":@{domains["II"]}.xyz,"III":@{domains["III"]}.xyz,"IV":@{domains["IV"]}.xyz,"V":@{domains["V"]}.xyz,"VI":@{domains["VI"]}.xyz}
		color {color = black} translucent 1.0
		domainArray = domains.keys.sort
		domainArrayCount = domainArray.size
		for (var i = 1; i <= domainArrayCount; i++) {
			var domainLabel1 = domainArray[i]
			select @{domains[domainLabel1]}
			var domainCenter = {selected}.xyz
			var displacement = domainCenter - riboCenter
			var parts_vector = displacement*2
			translateSelected @parts_vector
			select none
		}
		unpacked = "true"
	} else if (packing = "repack") {
		for (var i = 1; i <= domainArrayCount; i++) {
			var domainLabel1 = domainArray[i]
			select @{domains[domainLabel1]}
			var domainCenter = {selected}.xyz
			var restoreCoords = @{domainCoords[domainLabel1]} - domainCenter
			print restoreCoords
			translateSelected @restoreCoords
			select none
		}
		unpacked = "false"
	}
}
function SteitzMoore() {
		color {chain = 0} black
		color @{domains["I"]} red
		color @{domains["II"]} orange
		color @{domains["III"]} yellow
		color @{domains["IV"]} green
		color @{domains["V"]} blue
		color @{domains["VI"]} purple
}
function colorBleed() {
	set echo top left
	echo working...
	domainArray = domains.keys.sort
	domainArrayCount = domainArray.size
	for (var i = 1; i <= domainArrayCount; i++) {
		for (var j = 1; j <= domainArrayCount; j++) {
			if (i = j) {
				continue
			} else {
				var domainLabel1 = domainArray[i]
				var domainLabel2 = domainArray[j]
				var domainLabel2_color = @{domains[domainLabel2]}.color
				select @{domains[domainLabel1]}
				select selected and within(7, @{domains[domainLabel2]})
				color {selected} @domainLabel2_color
			}
		}
	}
	select none
	hide $top
}

function resnoEcho() {
	set echo bottom left
	display $bottom
	currentResno = {selected}.resno.max
	echo @currentResno
}

function setVisibility(doSetVisibility) {
	lastResidue = startTerminus
	visibilityRange = @{""+1+"-"+lastResidue}
	if (doSetVisibility = "hide") {
		hide hidden or {chain = 0 and nucleic and @visibilityRange}
	} else {
		display {chain = 0 and nucleic and @visibilityRange}
	}
}
function markDomain() {
	domainColor = prompt("Type a color for this region:",colorSet)
	if (pickDomain = "on") {
		color {selected} @domainColor
	} else {
		rangeStart = (rangeEnd != "" ? rangeEnd : 1)
		rangeEnd = startTerminus
		var domainRange = @{""+rangeStart+"-"+rangeEnd} 
		color {chain = 0 and @domainRange} @domainColor
		pause
	}
}

function restoreState() {
	if (unpacked = "true") { puzzlePieces("repack") }
	reset rangeStart
	reset rangeEnd
	doCheck = 0
	hide $top
	hide $bottom
	select {chain = 0 and nucleic}
	display selected
	restore orientation
	color {selected} group
	renderMode("spacefill")
	background white
}

function getMotifs() {
	kturns = ["42-50","77-82","92-100","111-115","147-149","244-250","259-267","936-941","1025-1034","1146-1155","1212-1217","1311-1319","1338-1343","1587-1593","1601-1608","2667-2668","2821-2829","2911-2914"]
	threeloop = ["119-121"]
	fourloop = ["253-256","469-472","577-580","691-694","805-808","1327-1330","1629-1632","1770-1773","1863-1866","2249-2252","2412-2415","2630-2633","2696-2699","2738-2741","2877-2880"]
	fiveloop = ["137-141","196-200","218-222","494-498","671-675","1055-1059","1431-1435","1469-1473","1595-1599","1794-1798","1169-1177","1834-1842"]
	sixloop = ["165-170","313-318","733-738","1197-1202","919-924","1077-1082","1688-1692","1917-1922"]
	sevenloop = ["84-90","335-341","417-423","1388-1394","872-878","1275-1281","1706-1712","1991-1997","2282-2288","2443-2449","2507-2513","2837-2843","2586-2592"]
	eightloop = ["391-398","624-631","1499-1506","2069-2076","2358-2365","2563-2570"]
	nineloop = ["1169-1177","1834-1842"]
	tenloop = ["55-64"]
	elevenloop = ["2299-2310","2389-2399","2782-2792"]
	loopslist = ["kturns","threeloop","fourloop","fiveloop","sixloop","sevenloop","eightloop","nineloop","tenloop","elevenloop"]
	loopslistsize = loopslist.size
	for (var i = 1; i <= loopslistsize; i++) {
		var arrayname = loopslist[i]
		var n = @arrayname.size
		for (var j = 1; j <= n; j++) {
			var arrayitem = @arrayname[j]
			select chain = 0 and {@arrayitem}
			{selected}.property_motif = i
			select none
		}
	}		
}

# Define sightSeeing

function sightSeeing(tourGuide) {
	delay @{(tourGuide = "on" and currentAtom > 0 ? slowSpeed : fastSpeed)} 
}


# Define labelMotifs

function labelMotifs(currentAtom) {
	if (currentAtom = 1) {
		display $top
		echo kink-turn
	} else if (currentAtom = 2) {
		display $top
		echo triloop
	} else if (currentAtom = 3) {
		display $top
		echo tetraloop
	} else if (currentAtom = 4) {
		display $top
		echo pentaloop
	} else if (currentAtom = 5) {
		display $top
		echo hexaloop
	} else if (currentAtom = 6) {
		display $top
		echo heptaloop
	} else if (currentAtom = 7) {
		display $top
		echo octaloop
	} else if (currentAtom = 8) {
		display $top
		echo nonaloop
	} else if (currentAtom = 9) {
		display $top
		echo decaloop
	} else if (currentAtom = 10) {
		display $top
		echo undecaloop
	} else if (currentAtom = "") {
		hide $top
	}
}
function visualRibosome(doVisualize) {
	restoreState
	switch (doVisualize) {
	case "buildWorm":
	case "fabricBall":
	case "buildWormHeadlights":
	case "wormTangle":
	case "navigateWorm":
	case "buildWormFill":
		switch (doVisualize) {
		case "navigateWorm":
		case "buildWormFill":
			color {displayed} translucent 0.95
			break
		case "buildWorm":
		case "fabricBall":
		case "buildWormHeadlights":
		case "wormTangle":
			display none
			if (doVisualize = "fabricBall") {
				select all
				renderMode("meshribbon")
			} else if (doVisualize = "wormTangle") {
				select all
				renderMode("strand")
			}
		}
		for (var i = 1; i <= n; i++) {
			select none
			var startTerminus = resnoList[i]
			var previousGroup = resnoList[i-1]
			if (i > 1) {
				select {chain = 0 and resno = previousGroup}
				switch(doVisualize) {
				case "buildWorm":
				case "buildWormFill":
				case "fabricBall":
				case "wormTangle":
					if (markMotifs = "on" and {selected}.property_motif > 0) {
						color {selected} white
					} else {
						color {selected} @terminalColor
					}
					break
				case "buildWormHeadlights":
					if (markMotifs = "on" and {selected}.property_motif > 0) {
						color {selected} opaque white
					} else {
						color {selected} opaque @terminalColor
					}
					break
				case "navigateWorm":
					color {selected} translucent 0.95
				}
			}
			var terminalColor = {chain = 0 and resno = startTerminus}.color
			if (doVisualize = "buildWormHeadlights") {
				var endTerminus = resnoList[i+6]
				var resnoRange = @{""+startTerminus+"-"+endTerminus}
				select {chain = 0 and @resnoRange}
			} else {
				select {chain = 0 and resno = startTerminus}
				var currentAtom = {selected}.property_motif
				labelMotifs(currentAtom)
			}
			resnoEcho()
			if (doVisualize != "navigateWorm") {
				display displayed or {selected}
			}
			if (centerSelected = "on") { center {selected} }
			switch(doVisualize) {
			case "buildWorm":
			case "fabricBall":
			case "wormTangle":
				color {selected} red
				break
			case "buildWormFill":
				color {selected} opaque red
				break
			case "buildWormHeadlights":
				color {selected} translucent 0.9
				break
			case "navigateWorm":
				color {selected} opaque
			}
			if (doVisualize = "buildWormHeadlights") {
				select {chain = 0 and resno = startTerminus}
				currentAtom = {selected}.property_motif
				labelMotifs(currentAtom)
				color {selected} opaque red
			}
			sightSeeing(tourGuide)
			checkPoint(doCheck)
			doCheck = 0
		}
		break
	case "candyCane":
		background black
		select all
		renderMode("strand")
		calculate hbonds
		set hbonds backbone
		color hbonds red
		bpSet = {chain = 0 and nucleic}.find("~*:*",true)
		h = bpSet.size
		nonbpSet = {chain = 0 and nucleic}.find("~*()",true)
		for (var i = 1; i <= h; i++) {
			bpID = bpSet[i]
			base1 = bpID[1]
			base2 = bpID[2]
			select base1 or within(group,base1)
			color {selected} red
			select base2 or within(group,base2)
			color {selected} pink
		}
		select nonbpSet or within(group,nonbpSet)
		color {selected} white translucent 1.0
		select none	
		break
	case "rollerCoaster":
		select visible
		renderMode("meshribbon")
		meshribbon 0.5
		navigate 2 trace (selected)
		currentAtom = {selected}.property_motif
		labelMotifs(currentAtom)	
	}
}

fastSpeed = 0.01
slowSpeed = 0.3
transparencyLevel = 1.0
set echo top left
set echo bottom left
n = {chain = 0 and *.P}.length
resnoList = {chain = 0 and *.P}.resno.all
getMotifs()
save orientation
riboCenter = {chain = 0 and nucleic}.xyz
draw ID centerPoint @riboCenter
