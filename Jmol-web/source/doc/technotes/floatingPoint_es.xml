<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
  Spanish translation 
  Translated from default version : floatingPoint_en.xml (v 1.1)
-->
<section title="Representaciones de números reales">
  <p>
    Alguien ha planteado la cuestión siguiente, que creo puede ser de interés general.
  </p>

  <p>
    Con respecto a la visualización de parámetros de la celda cristalina:
    <pre>
      > En algunos casos los valores a, b o c se muestran con decimales 'extra';
      > por ejemplo, la versión 10pre8 de la miniaplicación muestra a=10.436999 mientras que 
      > el registro CRYST1 del archivo pdb tiene el valor 10.437. Presumiblemente esto sea
      > una anomalía en el redondeo durante los cálculos de las coordenadas de la celda.
    </pre>
    En realidad, este caso en concreto es algo más sutil. No era realmente un problema de redondeo,
    pues no se había realizado ningún cálculo.
  </p>

  <p>
    Pero sigue siendo un problema. La <i>fuente</i> de este problema tiene interés
    general para aquéllos que trabajan con números reales (o de 'coma flotante').
  </p>

  <p>
    Estamos habituados a trabajar en base 10 (tenemos 10 dedos). De vez en cuando, 
    nos topamos con números racionales que no se pueden representar en base 10.
    Quizás los ejemplos más comunes sean 1/3 y 2/3.
    Los escribimos como 0.33 o 0.67, o bien los 
    extendemos unos cuantos dígitos más (0.33333 0.66667) si necesitamos más
    precisión en nuestros cálculos.
  </p>

  <p>
    Bien, llegamos al mismo problema en el mundo de la computación. Y la gente ha 
    estado peleando con las maneras de atacar este problema desde los comienzos de 
    los ordenadores digitales.
  </p>

  <p>
    La mayoría de ordenadores actuales utilizan generalmente una representación de coma flotante 
    definida en 1985 por el organismo normalizador IEEE:
    <code>
      IEEE Std 754-1985
      IEEE Standard for Binary Floating-Point Arithmetic
    </code>.

    Ésta es una representación en 'base 2' (binaria) de los números reales, no
    una representación en 'base 10'. Básicamente, esto significa que hay un juego diferente
    de números racionales que no se pueden representar con exactitud.
  </p>

  <p>
    En este caso, no hubo ningún cálculo sobre el número 10.437, que se leyó 
    directamente del archivo. Pero este número 10.437 no se puede representar 
    exactamente en binario, por lo que terminamos con 10.436999 (no he verificado esto 
    realmente, pero asumo que es lo que ocurre).
  </p>


  <p>
    Otros hechos aleatorios:
    <ul>
      <li>
	COBOL admitía números decimales y de coma fija para tratar con este problema
	en el caso de dólares y centavos en un entorno de negocio.
      </li>
      <li>
	Una de las representaciones en los macrocomputadores IBM era base 16 (en lugar
	de base 2). Aunque esto no resolvía este problema en particular, 
	sí proporcionaba un rendimiento más rápido (durante el proceso de 'normalización').
      </li>
      <li>
	Quienes quieren alto rendimiento, generalmente no siguen la norma IEEE.
      </li>
      <li>
	La especificación inicial de la máquina virtual Java *requería* la 
	representación IEEE (y su comportamiento operativo) para los números de coma flotante.
	Esto aseguraría la portabilidad entre plataformas; el mismo 
	cálculo debería dar el mismo resultado en sistemas diferentes. Este requisito
	se ha relajado algo desde entonces, para permitir 
	un cálculo de mayor rendimiento y debido a la aceptación de que es un 
	problema irresoluble.
      </li>
      <li>
	Creo que la mayoría de la gente está de acuerdo en que la norma IEEE tiene errores, pero
	debemos seguirla.
      </li>
      <li>
	Los sistemas dedicados a matemáticas simbólicas o puras (Mathematica, MATLAB, Macsyma)
	admiten números racionales (la representación fraccional con enteros: 1/3, 2/3) 
	para intentar evitar este tipo de problema con los números <i>racionales</i>.
      </li>
    </ul>
  </p>
</section>
