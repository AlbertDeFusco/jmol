<!--
  French translation 
  Translated from default version : noHeapMemory.xml (v 1.1)
-->
<section
  title="Pas d'allocation m&#x00E9;moire sur le tas pendant le cycle de dessin!">
  <p>
    Jmol n'alloue pas de m&#x00E9;moire sur le tas lors du cycle de
    redessin. Pour des raisons de performance, il est important que
    nous continuions &#x00E0; suivre cette r&#x00E8;gle.
  </p>

  <p>
    <i>[Dave a lu un brouillon de ce m&#x00E9;mo (version anglaise)
    et a donn&#x00E9; sa permission d'utiliser son code comme exemple]</i>
  </p>

  <p>
    En faisant une petite 'revue de code' du code r&#x00E9;cemment
    contribu&#x00E9; par Dave pour Ribbons/Mesh, j'ai vu quelque chose
    qui m&#x00E9;rite d'&#x00EA;tre discut&#x00E9;.
  </p>

  <p>
    Pour &#x00EA;tre clair, Dave a &#x00E9;crit du code excellent. Mais
    avec une petite modification nous pouvons nous assurer de maintenir
    des performances optimales. Et je vais utiliser ce code comme exemple
    pour faire prendre conscience des probl&#x00E8;mes d'allocation
    m&#x00E9;moire dans Jmol.
  </p>

  <p>
    Pour dessiner les Ribbons, Dave avait besoin de deux tableaux d'objets
    Point3i pour conserver les coordonn&#x00E9;es &#x00E9;cran des bords de
    ses rubans. Ainsi, il alloue les tableaux et les remplit avec de
    nouveaux objets Point3i. Des choses sont calcul&#x00E9;es, des choses
    sont dessin&#x00E9;es et de jolis rubans apparaissent &#x00E0;
    l'&#x00E9;cran.
  </p>

  <p>
    Et puis les objets temporaires sont poubellis&#x00E9;s. Et &#x00E0;
    cet endroit r&#x00E9;side un petit probl&#x00E8;me: les objets
    temporaires que nous allouons et lib&#x00E9;rons pendant le cycle
    de redessin.
  </p>

  <p>
    Pourquoi est-ce un probl&#x00E8;me?
  </p>

  <p>
    Bien, les cycles de redessin peuvent se produire plut&#x00F4;t
    rapidement ... esp&#x00E9;rons 30 fois par secondes pendant les
    rotations. Ainsi, si nous allouons des objets sur le tas [en
    utilisant new SomeObject(...)], alors nous pouvons aboutir &#x00E0;
    l'allocation de beaucoup d'entre eux rapidement.
  </p>

  <p>
    En fait, le probl&#x00E8;me n'est pas avec l'allocation. Le
    probl&#x00E8;me est avec la *d&#x00E9;sallocation*; nous supprimons
    imm&#x00E9;diatement les objets. Ces objets supprim&#x00E9;s donnent
    du travail inutile au garbage collector Java, qui doit parcourir la
    m&#x00E9;moire pour rechercher les structures supprim&#x00E9;es.
  </p>

  <p>
    Quand le garbade collector se d&#x00E9;clenche il peut parfois
    entra&#x00EE;ner des pauses ou des 'hocquets' dans les r&#x00E9;ponses
    du syst&#x00E8;me ... une mauvaise chose.
  </p>

  <p>
    En cons&#x00E9;quence, nous devons nous en occuper en faisant notre
    maximum pour 'recycler' les objets m&#x00E9;moire pendant le cycle de
    redessin.
  </p>

  <p>
    Nous pouvons obtenir ceci en associant les objets temporaires &#x00E0;
    des instances des classes Renderer. Nous pouvons demander aux instances
    de Renderer d'allouer/stocker les objets temporaires pour nous, et
    nous pouvons r&#x00E9;utiliser les m&#x00EA;mes objets temporaires
    &#x00E0; chaque fois pendant le cycle de redessin.
  </p>

  <p>
    Il y a d'autres parties du syst&#x00E8;me ou ces r&#x00E8;gles ne
    s'appliquent pas vraiment. Par exemple, pendant les op&#x00E9;rations
    d'E/S nous sommes libres d'allouer/lib&#x00E9;rer autant de choses
    que nous le voulons. Pendant les E/S nous devons faire beaucoup
    d'analyse de texte. Cette analyse entra&#x00EE;ne beaucoup de
    cha&#x00EE;nes de caract&#x00E8;res temporaires qui ont une
    dur&#x00E9;e de vie tr&#x00E8;s courte. Mais c'est bon car nous ne
    lisons pas de fichiers aussi souvent et parce que les utilisateurs
    s'attendent &#x00E0; ce que ce soit une op&#x00E9;ration relativement
    lente.
  </p>

</section>
